/* Generated by Nimrod Compiler v0.9.3 */
/*   (c) 2012 Andreas Rumpf */
/* The generated code is subject to the original license. */
/* Compiled for: MacOSX, amd64, clang */
/* Command for C compiler:
   clang -c  -w -O3  -I/Users/boyd/nimrod/lib -o /Users/boyd/Projects/nimrod-bloom/nimcache/nimrod-bloom_bloom.o /Users/boyd/Projects/nimrod-bloom/nimcache/nimrod-bloom_bloom.c */
#define NIM_INTBITS 64
#include "nimbase.h"

#include <stdio.h>

#include <string.h>

#include <math.h>

#include <setjmp.h>
typedef struct TGenericSeq TGenericSeq;
typedef struct NimStringDesc NimStringDesc;
typedef struct TNimType TNimType;
typedef struct TNimNode TNimNode;
typedef struct tbloomfilter94009 tbloomfilter94009;
typedef struct TY94015 TY94015;
typedef struct terrorfork93005 terrorfork93005;
typedef struct ebloomfilter94005 ebloomfilter94005;
typedef struct E_Base E_Base;
typedef struct TNimObject TNimObject;
typedef struct tcell38448 tcell38448;
typedef struct tcellseq38464 tcellseq38464;
typedef struct tgcheap40416 tgcheap40416;
typedef struct tcellset38460 tcellset38460;
typedef struct tpagedesc38456 tpagedesc38456;
typedef struct tmemregion21810 tmemregion21810;
typedef struct tsmallchunk21038 tsmallchunk21038;
typedef struct tllchunk21804 tllchunk21804;
typedef struct tbigchunk21040 tbigchunk21040;
typedef struct tintset21015 tintset21015;
typedef struct ttrunk21011 ttrunk21011;
typedef struct tavlnode21808 tavlnode21808;
typedef struct tgcstat40414 tgcstat40414;
typedef struct TSafePoint TSafePoint;
typedef struct TY96003 TY96003;
typedef struct tbasechunk21036 tbasechunk21036;
typedef struct tfreecell21028 tfreecell21028;
struct TGenericSeq {
NI len;
NI reserved;
};
typedef NIM_CHAR TY611[100000001];
struct NimStringDesc {
  TGenericSeq Sup;
TY611 data;
};
typedef NI tmurmurhashes94007[2];
typedef NI TY94353[2];
typedef N_NIMCALL_PTR(void, TY889) (void* p, NI op);
struct TNimType {
NI size;
NU8 kind;
NU8 flags;
TNimType* base;
TNimNode* node;
void* finalizer;
TY889 marker;
};
struct TNimNode {
NU8 kind;
NI offset;
TNimType* typ;
NCSTRING name;
NI len;
TNimNode** sons;
};
struct tbloomfilter94009 {
NI Capacity;
NF Errorrate;
NI Khashes;
NI Mbits;
TY94015* Intarray;
NI Nbitsperelem;
NIM_BOOL Usemurmurhash;
};
typedef terrorfork93005* tallerrorrates93007[13];
struct TNimObject {
TNimType* m_type;
};
struct E_Base {
  TNimObject Sup;
E_Base* parent;
NCSTRING name;
NimStringDesc* message;
NimStringDesc* trace;
};
struct ebloomfilter94005 {
  E_Base Sup;
};
struct tcell38448 {
NI Refcount;
TNimType* Typ;
};
struct tcellseq38464 {
NI Len;
NI Cap;
tcell38448** D;
};
struct tcellset38460 {
NI Counter;
NI Max;
tpagedesc38456* Head;
tpagedesc38456** Data;
};
typedef tsmallchunk21038* TY21822[512];
typedef ttrunk21011* ttrunkbuckets21013[256];
struct tintset21015 {
ttrunkbuckets21013 Data;
};
struct tmemregion21810 {
NI Minlargeobj;
NI Maxlargeobj;
TY21822 Freesmallchunks;
tllchunk21804* Llmem;
NI Currmem;
NI Maxmem;
NI Freemem;
NI Lastsize;
tbigchunk21040* Freechunkslist;
tintset21015 Chunkstarts;
tavlnode21808* Root;
tavlnode21808* Deleted;
tavlnode21808* Last;
tavlnode21808* Freeavlnodes;
};
struct tgcstat40414 {
NI Stackscans;
NI Cyclecollections;
NI Maxthreshold;
NI Maxstacksize;
NI Maxstackcells;
NI Cycletablesize;
NI64 Maxpause;
};
struct tgcheap40416 {
void* Stackbottom;
NI Cyclethreshold;
tcellseq38464 Zct;
tcellseq38464 Decstack;
tcellset38460 Cycleroots;
tcellseq38464 Tempstack;
NI Recgclock;
tmemregion21810 Region;
tgcstat40414 Stat;
};
typedef struct {
N_NIMCALL_PTR(NIM_BOOL, ClPrc) (E_Base* e, void* ClEnv);
void* ClEnv;
} TY10420;
struct TSafePoint {
TSafePoint* prev;
NI status;
jmp_buf context;
NIM_BOOL hasRaiseAction;
TY10420 raiseAction;
};
typedef NimStringDesc* TY94182[4];
typedef NI TY21018[8];
struct tpagedesc38456 {
tpagedesc38456* Next;
NI Key;
TY21018 Bits;
};
struct tbasechunk21036 {
NI Prevsize;
NI Size;
NIM_BOOL Used;
};
struct tsmallchunk21038 {
  tbasechunk21036 Sup;
tsmallchunk21038* Next;
tsmallchunk21038* Prev;
tfreecell21028* Freelist;
NI Free;
NI Acc;
NF Data;
};
struct tllchunk21804 {
NI Size;
NI Acc;
tllchunk21804* Next;
};
struct tbigchunk21040 {
  tbasechunk21036 Sup;
tbigchunk21040* Next;
tbigchunk21040* Prev;
NI Align;
NF Data;
};
struct ttrunk21011 {
ttrunk21011* Next;
NI Key;
TY21018 Bits;
};
typedef tavlnode21808* TY21814[2];
struct tavlnode21808 {
TY21814 Link;
NI Key;
NI Upperbound;
NI Level;
};
struct tfreecell21028 {
tfreecell21028* Next;
NI Zerofield;
};
struct TY94015 {
  TGenericSeq Sup;
  NI data[SEQ_DECL_SIZE];
};
struct terrorfork93005 {
  TGenericSeq Sup;
  NF data[SEQ_DECL_SIZE];
};
struct TY96003 {
  TGenericSeq Sup;
  NimStringDesc* data[SEQ_DECL_SIZE];
};
N_NIMCALL(void, MurmurHash3_x64_128)(NCSTRING key, NI len, NU32 seed, NI* outhashes);
N_NIMCALL(void, murmurhash_94028)(NimStringDesc* key, NU32 seed, tmurmurhashes94007* Result);
N_NOINLINE(void, chckNil)(void* p);
N_NIMCALL(void, genericReset)(void* dest, TNimType* mt);
N_NIMCALL(void, initializebloomfilter_94118)(NI capacity, NF errorrate, NI k, NI forcenbitsperelem, NIM_BOOL usemurmurhash, tbloomfilter94009* Result);
N_NIMCALL(NI, getmovernbitsfork_94062)(NI k, NF targeterror, tallerrorrates93007 probabilitytable);
N_NIMCALL(void, nimGCvisit)(void* d, NI op);
N_NIMCALL(void, TMP54)(void* p, NI op);
N_NIMCALL(void*, newObj)(TNimType* typ, NI size);
N_NIMCALL(NimStringDesc*, copyStringRC1)(NimStringDesc* src);
static N_INLINE(void, nimGCunrefNoCycle)(void* p);
static N_INLINE(tcell38448*, usrtocell_41839)(void* usr);
static N_INLINE(void, rtladdzct_43402)(tcell38448* c);
N_NOINLINE(void, addzct_41815)(tcellseq38464* s, tcell38448* c);
N_NIMCALL(void, raiseException)(E_Base* e, NCSTRING ename);
static N_INLINE(void, pushSafePoint)(TSafePoint* s);
static N_INLINE(void, popSafePoint)(void);
N_NIMCALL(NIM_BOOL, isObj)(TNimType* obj, TNimType* subclass);
static N_INLINE(E_Base*, getCurrentException)(void);
static N_INLINE(void, popCurrentException)(void);
static N_INLINE(void, asgnRefNoCycle)(void** dest, void* src);
N_NIMCALL(void, reraiseException)(void);
N_NIMCALL(TY94015*, newseq_94138)(NI len);
N_NIMCALL(void, TMP60)(void* p, NI op);
N_NIMCALL(void, genericShallowAssign)(void* dest, void* src, TNimType* mt);
N_NIMCALL(NimStringDesc*, HEX24_94176)(tbloomfilter94009* bf);
N_NIMCALL(NimStringDesc*, nsuFormatOpenArray)(NimStringDesc* formatstr, NimStringDesc** a, NI aLen0);
N_NIMCALL(NimStringDesc*, nimIntToStr)(NI x);
N_NIMCALL(NimStringDesc*, nsuformatFloat)(NF f, NU8 format, NI precision);
N_NIMCALL(NIM_BOOL, lookup_94323)(tbloomfilter94009* bf, NimStringDesc* item);
N_NIMCALL(TY94015*, hash_94267)(tbloomfilter94009* bf, NimStringDesc* item);
N_NIMCALL(TY94015*, hashmurmur_94187)(tbloomfilter94009* bf, NimStringDesc* item);
N_NIMCALL(TY94015*, hashnimrod_94231)(tbloomfilter94009* bf, NimStringDesc* item);
N_NIMCALL(void*, newSeq)(TNimType* typ, NI len);
N_NIMCALL(NI, hashn_94054)(NimStringDesc* item, NI n, NI maxvalue);
N_NIMCALL(NI, hasha_94040)(NimStringDesc* item, NI maxvalue);
N_NIMCALL(NI, hash_87827)(NimStringDesc* x);
N_NIMCALL(NI, hashb_94047)(NimStringDesc* item, NI maxvalue);
static N_INLINE(void, appendString)(NimStringDesc* dest, NimStringDesc* src);
N_NIMCALL(NimStringDesc*, rawNewString)(NI space);
N_NIMCALL(void, genericSeqAssign)(void* dest, void* src_70404, TNimType* mt);
N_NIMCALL(NimStringDesc*, nimBoolToStr)(NIM_BOOL x);
N_NIMCALL(void, insert_94275)(tbloomfilter94009* bf, NimStringDesc* item);
N_NIMCALL(void, randomize_77605)(NI seed);
N_NIMCALL(TY96003*, newseq_96008)(NI len);
N_NIMCALL(void, TMP72)(void* p, NI op);
N_NIMCALL(NimStringDesc*, copyString)(NimStringDesc* src);
N_NIMCALL(NI, random_77549)(NI max);
N_NIMCALL(NimStringDesc*, addChar)(NimStringDesc* s, NIM_CHAR c);
N_NIMCALL(NF, ntcpuTime)(void);
static N_INLINE(NF, HEX2F_74636)(NI x, NI y);
static N_INLINE(void, initStackBottom)(void);
N_NOINLINE(void, setStackBottom)(void* thestackbottom);
N_NOINLINE(void, systemInit)(void);
N_NOINLINE(void, systemDatInit)(void);
N_NOINLINE(void, puremathInit)(void);
N_NOINLINE(void, puremathDatInit)(void);
N_NOINLINE(void, pureparseutilsInit)(void);
N_NOINLINE(void, pureparseutilsDatInit)(void);
N_NOINLINE(void, purestrutilsInit)(void);
N_NOINLINE(void, purestrutilsDatInit)(void);
N_NOINLINE(void, purehashesInit)(void);
N_NOINLINE(void, purehashesDatInit)(void);
N_NOINLINE(void, puretimesInit)(void);
N_NOINLINE(void, puretimesDatInit)(void);
N_NOINLINE(void, nimrodHEX2DbloomprobabilitiesInit)(void);
N_NOINLINE(void, nimrodHEX2DbloomprobabilitiesDatInit)(void);
N_NOINLINE(void, bloomInit)(void);
N_NOINLINE(void, bloomDatInit)(void);
STRING_LITERAL(TMP49, "Testing MurmurHash3 code...", 27);
NIM_CONST TY94353 TMP50 = {0,
0}
;
STRING_LITERAL(TMP51, "hello", 5);
STRING_LITERAL(TMP55, "K must be <= 12 if force_n_bits_per_elem is not also specified.", 63);
STRING_LITERAL(TMP57, "Specified value of k and error rate for which is not achievable"
" using less than 4 bytes / element.", 98);
STRING_LITERAL(TMP63, "Bloom filter with $1 capacity, $2 error rate, $3 hash functions"
", and requiring $4 bits per stored element.", 106);
STRING_LITERAL(TMP64, "Testing insertions and lookups...", 33);
STRING_LITERAL(TMP65, "Test element in BF2?: ", 22);
STRING_LITERAL(TMP66, " b", 2);
STRING_LITERAL(TMP67, "testing", 7);
STRING_LITERAL(TMP70, "Inserting element.", 18);
STRING_LITERAL(TMP71, "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", 62);
STRING_LITERAL(TMP73, "", 0);
STRING_LITERAL(TMP74, "Took ", 5);
STRING_LITERAL(TMP75, " seconds to insert ", 19);
STRING_LITERAL(TMP76, " items.", 7);
STRING_LITERAL(TMP77, "N false positives (of ", 22);
STRING_LITERAL(TMP78, " lookups): ", 11);
STRING_LITERAL(TMP79, "False positive rate ", 20);
STRING_LITERAL(TMP80, " seconds to lookup ", 19);
STRING_LITERAL(TMP81, "N lookup errors (should be 0): ", 31);
tmurmurhashes94007 hashoutputs_94350;
tmurmurhashes94007 hashoutputs2_94601;
extern TNimType NTI105; /* int */
TNimType NTI94007; /* TMurmurHashes */
tmurmurhashes94007 hashoutputs3_95001;
NI nelementstotest_95402;
tbloomfilter94009 bf_95404;
extern TNimType NTI1025; /* E_Base */
TNimType NTI94005; /* EBloomFilter */
TNimType NTI94072; /* ref EBloomFilter */
extern tgcheap40416 gch_40444;
extern TSafePoint* exchandler_11826;
extern TNimType NTI1059; /* EInvalidIndex */
extern E_Base* currexception_11828;
extern tallerrorrates93007 kerrors_93010;
TNimType NTI94015; /* seq[int] */
TNimType NTI94009; /* TBloomFilter */
extern TNimType NTI125; /* float */
extern TNimType NTI133; /* bool */
tbloomfilter94009 bf2_95603;
NimStringDesc* samplechars_96002;
TY96003* ktestelements_96004;
TY96003* sampleletters_96005;
extern TNimType NTI142; /* string */
TNimType NTI96003; /* seq[string] */
NI i_96066;
NI j_96077;
NF starttime_96079;
NF endtime_96080;
NI i_96090;
NI falsepositives_96092;
NI i_96102;
NI j_96113;
NI lookuperrors_96124;
NI i_96134;
tbloomfilter94009 bf3_97003;

N_NIMCALL(void, murmurhash_94028)(NimStringDesc* key, NU32 seed, tmurmurhashes94007* Result) {
	tmurmurhashes94007 result;
	memcpy((void*)result, (NIM_CONST void*)TMP50, sizeof(result));
	MurmurHash3_x64_128(key->data, key->Sup.len, seed, result);	memcpy((void*)(*Result), (NIM_CONST void*)result, sizeof((*Result)));
	goto BeforeRet;
	BeforeRet: ;}N_NIMCALL(void, TMP54)(void* p, NI op) {
	ebloomfilter94005* a;
	a = (ebloomfilter94005*)p;
	nimGCvisit((void*)(*a).Sup.parent, op);
	nimGCvisit((void*)(*a).Sup.message, op);
	nimGCvisit((void*)(*a).Sup.trace, op);
}

static N_INLINE(tcell38448*, usrtocell_41839)(void* usr) {
	tcell38448* result;
	result = 0;
	result = ((tcell38448*) ((NI)((NU64)(((NI) (usr))) - (NU64)(((NI)sizeof(tcell38448))))));
	return result;
}
static N_INLINE(void, rtladdzct_43402)(tcell38448* c) {
	addzct_41815(&gch_40444.Zct, c);}
static N_INLINE(void, nimGCunrefNoCycle)(void* p) {
	tcell38448* c;
	c = usrtocell_41839(p);
	{
		(*c).Refcount -= 8;
		if (!((NU64)((*c).Refcount) < (NU64)(8))) goto LA3;
		rtladdzct_43402(c);	}	LA3: ;
}
static N_INLINE(void, pushSafePoint)(TSafePoint* s) {
	(*s).hasRaiseAction = NIM_FALSE;
	(*s).prev = exchandler_11826;
	exchandler_11826 = s;
}
static N_INLINE(void, popSafePoint)(void) {
	exchandler_11826 = (*exchandler_11826).prev;
}
static N_INLINE(E_Base*, getCurrentException)(void) {
	E_Base* result;
	result = 0;
	result = currexception_11828;
	return result;
}
static N_INLINE(void, asgnRefNoCycle)(void** dest, void* src) {
	{
		tcell38448* c;
		if (!!((src == NIM_NIL))) goto LA3;
		c = usrtocell_41839(src);
		(*c).Refcount += 8;
	}	LA3: ;
	{
		tcell38448* c;
		if (!!(((*dest) == NIM_NIL))) goto LA7;
		c = usrtocell_41839((*dest));
		{
			(*c).Refcount -= 8;
			if (!((NU64)((*c).Refcount) < (NU64)(8))) goto LA11;
			rtladdzct_43402(c);		}		LA11: ;
	}	LA7: ;
	(*dest) = src;
}
static N_INLINE(void, popCurrentException)(void) {
	asgnRefNoCycle((void**) &currexception_11828, (*currexception_11828).parent);
}
N_NIMCALL(NI, getmovernbitsfork_94062)(NI k, NF targeterror, tallerrorrates93007 probabilitytable) {
	NI result;
	NIM_BOOL searchingformovern;
	NI movern;
	result = 0;
	{
		ebloomfilter94005* e_94071;
		NimStringDesc* LOC5;
		if (!(12 < k)) goto LA3;
		e_94071 = 0;
		e_94071 = (ebloomfilter94005*) newObj((&NTI94072), sizeof(ebloomfilter94005));
		(*e_94071).Sup.Sup.m_type = (&NTI94005);
		LOC5 = 0;
		LOC5 = (*e_94071).Sup.message; (*e_94071).Sup.message = copyStringRC1(((NimStringDesc*) &TMP55));
		if (LOC5) nimGCunrefNoCycle(LOC5);
		raiseException((E_Base*)e_94071, "EBloomFilter");
	}	LA3: ;
	searchingformovern = NIM_TRUE;
	movern = 2;
	while (1) {
		TSafePoint TMP56;
		if (!searchingformovern) goto LA6;
		pushSafePoint(&TMP56);
		TMP56.status = setjmp(TMP56.context);
		if (TMP56.status == 0) {
			{
				if (!(probabilitytable[(k)- 0]->data[movern] < targeterror)) goto LA10;
				searchingformovern = NIM_FALSE;
				result = movern;
				popSafePoint();
				goto BeforeRet;
			}			goto LA8;
			LA10: ;
			{
				movern += 1;
			}			LA8: ;
			popSafePoint();
		}		else {
			popSafePoint();
			if (isObj(getCurrentException()->Sup.m_type, (&NTI1059))) {
				ebloomfilter94005* volatile e_94099;
				NimStringDesc* LOC15;
				TMP56.status = 0;
				e_94099 = 0;
				e_94099 = (ebloomfilter94005*) newObj((&NTI94072), sizeof(ebloomfilter94005));
				(*e_94099).Sup.Sup.m_type = (&NTI94005);
				LOC15 = 0;
				LOC15 = (*e_94099).Sup.message; (*e_94099).Sup.message = copyStringRC1(((NimStringDesc*) &TMP57));
				if (LOC15) nimGCunrefNoCycle(LOC15);
				raiseException((E_Base*)e_94099, "EBloomFilter");
				popCurrentException();
			}		}		if (TMP56.status != 0) reraiseException();
	} LA6: ;
	BeforeRet: ;	return result;
}N_NIMCALL(void, TMP60)(void* p, NI op) {
	TY94015* a;
	NI LOC1;
	a = (TY94015*)p;
	LOC1 = 0;
	for (LOC1 = 0; LOC1 < a->Sup.len; LOC1++) {
	}
}

N_NIMCALL(void, initializebloomfilter_94118)(NI capacity, NF errorrate, NI k, NI forcenbitsperelem, NIM_BOOL usemurmurhash, tbloomfilter94009* Result) {
	NI khashes;
	NF bitsperelem;
	NI nbitsperelem;
	NI mbits;
	NI mints;
	tbloomfilter94009 LOC15;
	khashes = 0;
	bitsperelem = 0;
	nbitsperelem = 0;
	{
		NF LOC5;
		NF LOC6;
		NF LOC7;
		NF LOC8;
		if (!(k < 1)) goto LA3;
		LOC5 = 0;
		LOC5 = log(errorrate);
		LOC6 = 0;
		LOC6 = log(2.0000000000000000e+00);
		LOC7 = 0;
		LOC7 = pow(LOC6, 2.0000000000000000e+00);
		bitsperelem = ceil(((NF)(-1.0000000000000000e+00) * (NF)(((NF)(LOC5) / (NF)(LOC7)))));
		LOC8 = 0;
		LOC8 = log(2.0000000000000000e+00);
		khashes = lrint(((NF)(LOC8) * (NF)(bitsperelem)));
		nbitsperelem = lrint(bitsperelem);
	}	goto LA1;
	LA3: ;
	{
		{
			if (!(forcenbitsperelem < 1)) goto LA12;
			nbitsperelem = getmovernbitsfork_94062(k, errorrate, kerrors_93010);
		}		goto LA10;
		LA12: ;
		{
			nbitsperelem = forcenbitsperelem;
		}		LA10: ;
		khashes = k;
	}	LA1: ;
	mbits = (NI64)(capacity * nbitsperelem);
	mints = (NI64)(1 + (NI64)(mbits / 64));
	memset((void*)&LOC15, 0, sizeof(LOC15));
	LOC15.Capacity = capacity;
	LOC15.Errorrate = errorrate;
	LOC15.Khashes = khashes;
	LOC15.Mbits = mbits;
	asgnRefNoCycle((void**) &LOC15.Intarray, newseq_94138(mints));
	LOC15.Nbitsperelem = nbitsperelem;
	LOC15.Usemurmurhash = usemurmurhash;
	genericShallowAssign((void*)Result, (void*)&LOC15, (&NTI94009));
}
N_NIMCALL(NimStringDesc*, HEX24_94176)(tbloomfilter94009* bf) {
	NimStringDesc* result;
	TY94182 LOC1;
	result = 0;
	memset((void*)LOC1, 0, sizeof(LOC1));
	LOC1[0] = nimIntToStr((*bf).Capacity);
	LOC1[1] = nsuformatFloat((*bf).Errorrate, ((NU8) 2), 1);
	LOC1[2] = nimIntToStr((*bf).Khashes);
	LOC1[3] = nimIntToStr((*bf).Nbitsperelem);
	result = nsuFormatOpenArray(((NimStringDesc*) &TMP63), LOC1, 4);
	return result;
}
N_NIMCALL(TY94015*, hashmurmur_94187)(tbloomfilter94009* bf, NimStringDesc* item) {
	TY94015* result;
	tmurmurhashes94007 murmurhashes;
	NI i_94222;
	NI HEX3Atmp_94223;
	NI res_94225;
	result = 0;
	result = newseq_94138((*bf).Khashes);
	chckNil((void*)murmurhashes);
	memset((void*)murmurhashes, 0, sizeof(murmurhashes));
	murmurhash_94028(item, ((NU32) 0), murmurhashes);	i_94222 = 0;
	HEX3Atmp_94223 = 0;
	HEX3Atmp_94223 = (NI64)((*bf).Khashes - 1);
	res_94225 = 0;
	while (1) {
		if (!(res_94225 <= HEX3Atmp_94223)) goto LA1;
		i_94222 = res_94225;
		result->data[i_94222] = (NI64)((NI64)abs((NI64)(murmurhashes[(0)- 0] + (NI64)(i_94222 * murmurhashes[(1)- 0]))) % (*bf).Mbits);
		res_94225 += 1;
	} LA1: ;
	goto BeforeRet;
	BeforeRet: ;	return result;
}
N_NIMCALL(NI, hasha_94040)(NimStringDesc* item, NI maxvalue) {
	NI result;
	NI LOC1;
	result = 0;
	LOC1 = 0;
	LOC1 = hash_87827(item);
	result = (NI64)(LOC1 % maxvalue);
	return result;
}
static N_INLINE(void, appendString)(NimStringDesc* dest, NimStringDesc* src) {
	memcpy(((NCSTRING) (&(*dest).data[((*dest).Sup.len)- 0])), ((NCSTRING) ((*src).data)), (NI64)((*src).Sup.len + 1));	(*dest).Sup.len += (*src).Sup.len;
}
N_NIMCALL(NI, hashb_94047)(NimStringDesc* item, NI maxvalue) {
	NI result;
	NimStringDesc* LOC1;
	NI LOC2;
	result = 0;
	LOC1 = 0;
	LOC1 = rawNewString(item->Sup.len + 2);
appendString(LOC1, item);
appendString(LOC1, ((NimStringDesc*) &TMP66));
	LOC2 = 0;
	LOC2 = hash_87827(LOC1);
	result = (NI64)(LOC2 % maxvalue);
	return result;
}
N_NIMCALL(NI, hashn_94054)(NimStringDesc* item, NI n, NI maxvalue) {
	NI result;
	NI LOC1;
	NI LOC2;
	result = 0;
	LOC1 = 0;
	LOC1 = hasha_94040(item, maxvalue);
	LOC2 = 0;
	LOC2 = hashb_94047(item, maxvalue);
	result = (NI64)((NI64)abs((NI64)(LOC1 + (NI64)(n * LOC2))) % maxvalue);
	return result;
}
N_NIMCALL(TY94015*, hashnimrod_94231)(tbloomfilter94009* bf, NimStringDesc* item) {
	TY94015* result_94236;
	TY94015* result;
	NI i_94258;
	NI HEX3Atmp_94260;
	NI res_94262;
	result_94236 = 0;
	result = 0;
	result = (TY94015*) newSeq((&NTI94015), (*bf).Khashes);
	i_94258 = 0;
	HEX3Atmp_94260 = 0;
	HEX3Atmp_94260 = (NI64)((*bf).Khashes - 1);
	res_94262 = 0;
	while (1) {
		if (!(res_94262 <= HEX3Atmp_94260)) goto LA1;
		i_94258 = res_94262;
		result->data[i_94258] = hashn_94054(item, i_94258, (*bf).Mbits);
		res_94262 += 1;
	} LA1: ;
	genericSeqAssign(&result_94236, result, (&NTI94015));
	goto BeforeRet;
	BeforeRet: ;	return result_94236;
}
N_NIMCALL(TY94015*, hash_94267)(tbloomfilter94009* bf, NimStringDesc* item) {
	TY94015* result;
	result = 0;
	{
		if (!(*bf).Usemurmurhash) goto LA3;
		result = hashmurmur_94187(bf, item);
	}	goto LA1;
	LA3: ;
	{
		result = hashnimrod_94231(bf, item);
	}	LA1: ;
	goto BeforeRet;
	BeforeRet: ;	return result;
}
N_NIMCALL(NIM_BOOL, lookup_94323)(tbloomfilter94009* bf, NimStringDesc* item) {
	NIM_BOOL result;
	TY94015* hashset;
	NI h_94338;
	NI i_94346;
	result = 0;
	hashset = hash_94267(bf, item);
	h_94338 = 0;
	i_94346 = 0;
	while (1) {
		NI intaddress;
		NI bitoffset;
		NI currentint;
		if (!(i_94346 < hashset->Sup.len)) goto LA1;
		h_94338 = hashset->data[i_94346];
		intaddress = (NI64)(h_94338 / 64);
		bitoffset = (NI64)(h_94338 % 64);
		currentint = (*bf).Intarray->data[intaddress];
		{
			if (!!((currentint == (NI)(currentint | (NI)((NU64)(1) << (NU64)(((NI) (bitoffset)))))))) goto LA4;
			result = NIM_FALSE;
			goto BeforeRet;
		}		LA4: ;
		i_94346 += 1;
	} LA1: ;
	result = NIM_TRUE;
	goto BeforeRet;
	BeforeRet: ;	return result;
}
N_NIMCALL(void, insert_94275)(tbloomfilter94009* bf, NimStringDesc* item) {
	TY94015* hashset;
	NI h_94312;
	NI i_94319;
	hashset = hash_94267(&(*bf), item);
	h_94312 = 0;
	i_94319 = 0;
	while (1) {
		NI intaddress;
		NI bitoffset;
		if (!(i_94319 < hashset->Sup.len)) goto LA1;
		h_94312 = hashset->data[i_94319];
		intaddress = (NI64)(h_94312 / 64);
		bitoffset = (NI64)(h_94312 % 64);
		(*bf).Intarray->data[intaddress] = (NI)((*bf).Intarray->data[intaddress] | (NI)((NU64)(1) << (NU64)(((NI) (bitoffset)))));
		i_94319 += 1;
	} LA1: ;
}N_NIMCALL(void, TMP72)(void* p, NI op) {
	TY96003* a;
	NI LOC1;
	a = (TY96003*)p;
	LOC1 = 0;
	for (LOC1 = 0; LOC1 < a->Sup.len; LOC1++) {
	nimGCvisit((void*)a->data[LOC1], op);
	}
}

static N_INLINE(NF, HEX2F_74636)(NI x, NI y) {
	NF result;
	result = 0;
	result = ((NF)(((double) (x))) / (NF)(((double) (y))));
	return result;
}
static N_INLINE(void, initStackBottom)(void) {
	void* volatile locals;
	locals = 0;
	locals = ((void*) (&locals));
	setStackBottom(locals);}int cmdCount;
char** cmdLine;
char** gEnv;
N_CDECL(void, NimMain)(void) {
	systemDatInit();
	puremathDatInit();
	pureparseutilsDatInit();
	purestrutilsDatInit();
	purehashesDatInit();
	puretimesDatInit();
	nimrodHEX2DbloomprobabilitiesDatInit();
	bloomDatInit();
	initStackBottom();
	systemInit();
	puremathInit();
	pureparseutilsInit();
	purestrutilsInit();
	purehashesInit();
	puretimesInit();
	nimrodHEX2DbloomprobabilitiesInit();
	bloomInit();
}
int main(int argc, char** args, char** env) {
	cmdLine = args;
	cmdCount = argc;
	gEnv = env;
	NimMain();
	return nim_program_result;
}
N_NOINLINE(void, bloomInit)(void) {
	NimStringDesc* LOC1;
	NimStringDesc* LOC2;
	NIM_BOOL LOC3;
	NimStringDesc* LOC4;
	NIM_BOOL LOC5;
	NimStringDesc* LOC6;
	NimStringDesc* LOC7;
	NI HEX3Atmp_97407;
	NI res_97409;
	NI HEX3Atmp_97413;
	NI res_97415;
	NimStringDesc* LOC13;
	NimStringDesc* LOC14;
	NI HEX3Atmp_97420;
	NI res_97422;
	NimStringDesc* LOC23;
	NimStringDesc* LOC24;
	NF LOC25;
	NimStringDesc* LOC26;
	NI HEX3Atmp_97424;
	NI res_97426;
	NimStringDesc* LOC33;
	NimStringDesc* LOC34;
	NimStringDesc* LOC35;
	TSafePoint TMP82;
	printf("%s\012", (((NimStringDesc*) &TMP49))->data);
	memcpy((void*)hashoutputs_94350, (NIM_CONST void*)TMP50, sizeof(hashoutputs_94350));
	MurmurHash3_x64_128("hello", 5, ((NU32) 0), hashoutputs_94350);	chckNil((void*)hashoutputs2_94601);
	genericReset((void*)hashoutputs2_94601, (&NTI94007));
	murmurhash_94028(((NimStringDesc*) &TMP51), ((NU32) 0), hashoutputs2_94601);	chckNil((void*)hashoutputs3_95001);
	genericReset((void*)hashoutputs3_95001, (&NTI94007));
	murmurhash_94028(((NimStringDesc*) &TMP51), ((NU32) 10), hashoutputs3_95001);	nelementstotest_95402 = 10000000;
	chckNil((void*)&bf_95404);
	genericReset((void*)&bf_95404, (&NTI94009));
	initializebloomfilter_94118(nelementstotest_95402, 1.0000000000000000e-03, 5, 0, NIM_TRUE, &bf_95404);	LOC1 = 0;
	LOC1 = HEX24_94176(&bf_95404);
	printf("%s\012", (LOC1)->data);
	chckNil((void*)&bf2_95603);
	genericReset((void*)&bf2_95603, (&NTI94009));
	initializebloomfilter_94118(10000, 1.0000000000000000e-03, 4, 20, NIM_TRUE, &bf2_95603);	LOC2 = 0;
	LOC2 = HEX24_94176(&bf2_95603);
	printf("%s\012", (LOC2)->data);
	printf("%s\012", (((NimStringDesc*) &TMP64))->data);
	LOC3 = 0;
	LOC3 = lookup_94323(&bf2_95603, ((NimStringDesc*) &TMP67));
	LOC4 = 0;
	LOC4 = nimBoolToStr(LOC3);
	printf("%s%s\012", (((NimStringDesc*) &TMP65))->data, (LOC4)->data);
	printf("%s\012", (((NimStringDesc*) &TMP70))->data);
	insert_94275(&bf2_95603, ((NimStringDesc*) &TMP67));	LOC5 = 0;
	LOC5 = lookup_94323(&bf2_95603, ((NimStringDesc*) &TMP67));
	LOC6 = 0;
	LOC6 = nimBoolToStr(LOC5);
	printf("%s%s\012", (((NimStringDesc*) &TMP65))->data, (LOC6)->data);
	randomize_77605(2882);	LOC7 = 0;
	LOC7 = samplechars_96002; samplechars_96002 = copyStringRC1(((NimStringDesc*) &TMP71));
	if (LOC7) nimGCunrefNoCycle(LOC7);
	asgnRefNoCycle((void**) &ktestelements_96004, newseq_96008(nelementstotest_95402));
	asgnRefNoCycle((void**) &sampleletters_96005, newseq_96008(62));
	HEX3Atmp_97407 = 0;
	HEX3Atmp_97407 = (NI64)(nelementstotest_95402 - 1);
	res_97409 = 0;
	while (1) {
		NimStringDesc* newstring;
		NI res_97405;
		NimStringDesc* LOC11;
		if (!(res_97409 <= HEX3Atmp_97407)) goto LA8;
		i_96066 = res_97409;
		newstring = copyString(((NimStringDesc*) &TMP73));
		j_96077 = 0;
		res_97405 = 0;
		while (1) {
			NI LOC10;
			if (!(res_97405 <= 7)) goto LA9;
			j_96077 = res_97405;
			LOC10 = 0;
			LOC10 = random_77549(51);
			newstring = addChar(newstring, samplechars_96002->data[LOC10]);
			res_97405 += 1;
		} LA9: ;
		LOC11 = 0;
		LOC11 = ktestelements_96004->data[i_96066]; ktestelements_96004->data[i_96066] = copyStringRC1(newstring);
		if (LOC11) nimGCunrefNoCycle(LOC11);
		res_97409 += 1;
	} LA8: ;
	starttime_96079 = ntcpuTime();
	HEX3Atmp_97413 = 0;
	HEX3Atmp_97413 = (NI64)(nelementstotest_95402 - 1);
	res_97415 = 0;
	while (1) {
		if (!(res_97415 <= HEX3Atmp_97413)) goto LA12;
		i_96090 = res_97415;
		insert_94275(&bf_95404, ktestelements_96004->data[i_96090]);		res_97415 += 1;
	} LA12: ;
	endtime_96080 = ntcpuTime();
	LOC13 = 0;
	LOC13 = nsuformatFloat(((NF)(endtime_96080) - (NF)(starttime_96079)), ((NU8) 1), 4);
	LOC14 = 0;
	LOC14 = nimIntToStr(nelementstotest_95402);
	printf("%s%s%s%s%s\012", (((NimStringDesc*) &TMP74))->data, (LOC13)->data, (((NimStringDesc*) &TMP75))->data, (LOC14)->data, (((NimStringDesc*) &TMP76))->data);
	falsepositives_96092 = 0;
	HEX3Atmp_97420 = 0;
	HEX3Atmp_97420 = (NI64)(nelementstotest_95402 - 1);
	res_97422 = 0;
	while (1) {
		NimStringDesc* falsepositivestring;
		NI res_97418;
		if (!(res_97422 <= HEX3Atmp_97420)) goto LA15;
		i_96102 = res_97422;
		falsepositivestring = copyString(((NimStringDesc*) &TMP73));
		j_96113 = 0;
		res_97418 = 0;
		while (1) {
			NI LOC17;
			if (!(res_97418 <= 8)) goto LA16;
			j_96113 = res_97418;
			LOC17 = 0;
			LOC17 = random_77549(51);
			falsepositivestring = addChar(falsepositivestring, samplechars_96002->data[LOC17]);
			res_97418 += 1;
		} LA16: ;
		{
			NIM_BOOL LOC20;
			LOC20 = 0;
			LOC20 = lookup_94323(&bf_95404, falsepositivestring);
			if (!LOC20) goto LA21;
			falsepositives_96092 += 1;
		}		LA21: ;
		res_97422 += 1;
	} LA15: ;
	LOC23 = 0;
	LOC23 = nimIntToStr(nelementstotest_95402);
	LOC24 = 0;
	LOC24 = nimIntToStr(falsepositives_96092);
	printf("%s%s%s%s\012", (((NimStringDesc*) &TMP77))->data, (LOC23)->data, (((NimStringDesc*) &TMP78))->data, (LOC24)->data);
	LOC25 = 0;
	LOC25 = HEX2F_74636(falsepositives_96092, nelementstotest_95402);
	LOC26 = 0;
	LOC26 = nsuformatFloat(LOC25, ((NU8) 1), 4);
	printf("%s%s\012", (((NimStringDesc*) &TMP79))->data, (LOC26)->data);
	lookuperrors_96124 = 0;
	starttime_96079 = ntcpuTime();
	HEX3Atmp_97424 = 0;
	HEX3Atmp_97424 = (NI64)(nelementstotest_95402 - 1);
	res_97426 = 0;
	while (1) {
		if (!(res_97426 <= HEX3Atmp_97424)) goto LA27;
		i_96134 = res_97426;
		{
			NIM_BOOL LOC30;
			LOC30 = 0;
			LOC30 = lookup_94323(&bf_95404, ktestelements_96004->data[i_96134]);
			if (!!(LOC30)) goto LA31;
			lookuperrors_96124 += 1;
		}		LA31: ;
		res_97426 += 1;
	} LA27: ;
	endtime_96080 = ntcpuTime();
	LOC33 = 0;
	LOC33 = nsuformatFloat(((NF)(endtime_96080) - (NF)(starttime_96079)), ((NU8) 1), 4);
	LOC34 = 0;
	LOC34 = nimIntToStr(nelementstotest_95402);
	printf("%s%s%s%s%s\012", (((NimStringDesc*) &TMP74))->data, (LOC33)->data, (((NimStringDesc*) &TMP80))->data, (LOC34)->data, (((NimStringDesc*) &TMP76))->data);
	LOC35 = 0;
	LOC35 = nimIntToStr(lookuperrors_96124);
	printf("%s%s\012", (((NimStringDesc*) &TMP81))->data, (LOC35)->data);
	pushSafePoint(&TMP82);
	TMP82.status = setjmp(TMP82.context);
	if (TMP82.status == 0) {
		NI volatile m1;
		m1 = getmovernbitsfork_94062(2, 1.0000000000000001e-05, kerrors_93010);
		popSafePoint();
	}	else {
		popSafePoint();
		if (isObj(getCurrentException()->Sup.m_type, (&NTI94005))) {
			TMP82.status = 0;
			popCurrentException();
		}	}	if (TMP82.status != 0) reraiseException();
	chckNil((void*)&bf3_97003);
	genericReset((void*)&bf3_97003, (&NTI94009));
	initializebloomfilter_94118(1000, 1.0000000000000000e-02, 4, 0, NIM_TRUE, &bf3_97003);}

N_NOINLINE(void, bloomDatInit)(void) {
static TNimNode* TMP61[7];
static TNimNode TMP3[9];
NTI94007.size = sizeof(tmurmurhashes94007);
NTI94007.kind = 16;
NTI94007.base = (&NTI105);
NTI94007.flags = 3;
NTI94005.size = sizeof(ebloomfilter94005);
NTI94005.kind = 17;
NTI94005.base = (&NTI1025);
NTI94005.flags = 2;
TMP3[0].len = 0; TMP3[0].kind = 2;
NTI94005.node = &TMP3[0];
NTI94072.size = sizeof(ebloomfilter94005*);
NTI94072.kind = 22;
NTI94072.base = (&NTI94005);
NTI94072.flags = 2;
NTI94072.marker = TMP54;
NTI94015.size = sizeof(TY94015*);
NTI94015.kind = 24;
NTI94015.base = (&NTI105);
NTI94015.flags = 2;
NTI94015.marker = TMP60;
NTI94009.size = sizeof(tbloomfilter94009);
NTI94009.kind = 18;
NTI94009.base = 0;
NTI94009.flags = 2;
TMP61[0] = &TMP3[2];
TMP3[2].kind = 1;
TMP3[2].offset = offsetof(tbloomfilter94009, Capacity);
TMP3[2].typ = (&NTI105);
TMP3[2].name = "capacity";
TMP61[1] = &TMP3[3];
TMP3[3].kind = 1;
TMP3[3].offset = offsetof(tbloomfilter94009, Errorrate);
TMP3[3].typ = (&NTI125);
TMP3[3].name = "error_rate";
TMP61[2] = &TMP3[4];
TMP3[4].kind = 1;
TMP3[4].offset = offsetof(tbloomfilter94009, Khashes);
TMP3[4].typ = (&NTI105);
TMP3[4].name = "k_hashes";
TMP61[3] = &TMP3[5];
TMP3[5].kind = 1;
TMP3[5].offset = offsetof(tbloomfilter94009, Mbits);
TMP3[5].typ = (&NTI105);
TMP3[5].name = "m_bits";
TMP61[4] = &TMP3[6];
TMP3[6].kind = 1;
TMP3[6].offset = offsetof(tbloomfilter94009, Intarray);
TMP3[6].typ = (&NTI94015);
TMP3[6].name = "int_array";
TMP61[5] = &TMP3[7];
TMP3[7].kind = 1;
TMP3[7].offset = offsetof(tbloomfilter94009, Nbitsperelem);
TMP3[7].typ = (&NTI105);
TMP3[7].name = "n_bits_per_elem";
TMP61[6] = &TMP3[8];
TMP3[8].kind = 1;
TMP3[8].offset = offsetof(tbloomfilter94009, Usemurmurhash);
TMP3[8].typ = (&NTI133);
TMP3[8].name = "use_murmur_hash";
TMP3[1].len = 7; TMP3[1].kind = 2; TMP3[1].sons = &TMP61[0];
NTI94009.node = &TMP3[1];
NTI96003.size = sizeof(TY96003*);
NTI96003.kind = 24;
NTI96003.base = (&NTI142);
NTI96003.flags = 2;
NTI96003.marker = TMP72;
}

